看到这题的第一眼，恨不得以为自己下错题了，看成预赛的题了。。。

当然，不得不说，这题能做出来，偶然无聊做了下预赛那题有很大帮助。
既然如此，writeup 就得从预赛那题说起。

apk 就不说了，安卓题出成纯 so 确实没啥意思，总之一个巨大的 verify 函数，F5 跑个半小时？跑出来 2W 多行一脸懵逼。
弯路就不说了，直接上正轨。

首先发现程序是强行 inline + 循环展开，然后内嵌了各种密码算法，随便拉几个常量出来搜搜就有 DES、SHA1、SM3，这是直接来了个密码算法大礼包啊。
然后还有几个简单的小加密，大概是自己编出来的，又解密出一堆字符串，当成常量再去搜搜，会发现一个调用频率很高的函数是解密出了 Rijndael 的 `S-box`，还有个解密出 `reverse S-box` 的，基本确定用了 Rijndael 了，不过不知道会不会是 AES 了（心中默默跪求没有改过标准算法）。

算法识别出来之后，就是对代码按照算法进行分块，确认大的流程（记得把代码从 IDA 复制到编辑器，有折叠的那种`(>_>)`）。分块好后，基本可以发现就用了 SHA1、SM3、Rijndael。然后剩下的就是下断在每个块的前后去看输入输出，确认一切和预期一样了。（IDA 不能给 ARM 下内存断、硬断差评！）

* SHA1 首先确认下来没问题

* SM3 怎么样也对不上，但是可以发现 SM3 只影响 Rijndael 的密钥（猜也能猜到 SM3 永远与我们的输入无关，毕竟 hash 算法不可逆啊，虽然不排除会留几位让爆破的可能性）
途中发现每次 SM3 都配上了一个自定义的简单异或变换。

* Rijndael 首先发现了个 `!= 16` 的循环，以为是 16 轮，最终种种原因无果。
仔细观察发现 `!= 16` 实际是循环 4 次，然后发现外层循环 10 轮，AES 可能性无限增大。
AES ECB 尝试无果，尝试切 CBC 等模式（试密钥）仍旧无果，难道真的改算法了？
单步跟入，发现密钥（有密钥展开应该不会认错）上来先与明文异或，= =，怎么嗅到一股 CBC 的气味，`IV = 密钥？`，测试通过，bingo！

剩下的就是苦力活，预赛 over，进入正赛。

打开 JNI onload 就嗅到一股 ollvm 的气息，这是对预赛题加了个混淆的版本？
**心中千万只羊驼结伴而过。**
按照惯例，看到这种无聊的玩法，应该还是滚回去玩 33c3，然而有命令在身，还是只好继续抛弃 33c3 的队友了。

ollvm 脱掉是不指望了，F5 都不指望跑出来，不过既然估计跟预赛差不多，就蒙蒙猜猜的走吧。首先看一眼算法大礼包应该没变，那么接下来还是跟数据流吧（没有内存断继续差评）。

考虑到初赛题很多块与块间有个 memcpy，于是下断看内存（不会 IDC 感觉吃了大亏！！！）。
跟下来可以发现前面一半跟预赛基本一致，改了几个常量而已。
后面就无故蹦出来一堆来路不明字符串。

几番挣扎，发现几乎所有来路不明的字符串都是前面的某些串经过之前那个自定义的异或变换来的。
以为大功告成梳理时，发现有一个地方断掉了，一个关键串还是来路不明。
无奈之下，给 malloc 下断，监控分配出的内存变化，发现那个串还是在某两次断点间突然出现，并且找不到相关串。

接下来也没了别的选择，既然关键位置已经确定，那就硬着头皮单步跟了。
总算跟到关键代码，感觉又是个麻烦的算法，但并不认识。
代码跟 AES 有相似度，但又不肯定是，中间有个 0x20 轮的循环为主体，那就一点点跟着看吧，实在不行只好自己看完了重写了。

这时，突然发现，IDA 窗口怎么好像少了一个？？？！！！
？？？F5 跑出来了！！！
赶快拿常量回去定位，拼凑出这个算法的 C 代码，不管咋说，总比看汇编好。
精简好代码，快速看一遍，很明显发现有张常量表，Google 一下，SM4，bingo！

PS：很佩服前面那位逆了整个算法的重写的，耐力真非常人所能及也。。。
