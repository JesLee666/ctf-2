#equation crypto 2
这道题给出一张图片，内容是RSA私钥的后半部分，根据题意要恢复出整个私钥，也就是找到原来的p和q。
这到题首先google了好久，结果走了弯路，找到了以前plaid ctf的一道题目，理论依据是一篇论文，讲的是随机撤掉私钥中70%左右的bit都可以恢复。
后来仔细看了一些那道题的writeup，发现有几个方程可以用:`http://mslc.ctf.su/wp/plaidctf-2014-rsa-writeup/`
自己人肉decode一下私钥可以得到`dp`和`dq`，然后找帖子中的代码，遍历kp和kq（这里认为e是65537），就可以算出pq，而且算q的时候可以根据私钥中残缺的q来判断。
然后用`rsatool`就可以恢复出整个私钥。

当时写的代码，有些乱：

```python
dp = 11188888442779478492506783674852186314949555636014740182307607993518479864690065244102864238986781155531033697982611187514703037389481147794554444962262361L
dq = 1006725509429627901220283238134032802363853505667837273574181077068133214344166038422298631614477333564791953596600001816371928482096290600710984197710579L
e = 65537
qq = '3acf6684e41176a5b673056b9cd23bd832dc017a57509d471b'
q = 0xeeb8defdf9f0aec0036116ac9d84ab925e7606e9ba4618bfc50d7fa42d3ecf7901aa5867c782ea3acf6684e41176a5b673056b9cd23bd832dc017a57509d471b
qi = 11196804284042107547423407831525890933636414684075355664222816007929037065463409676450144484947842399975707117057331864113464711778199061912128258484839473L

for kq in range(1, e):
	q = hex((e * dq - 1) / kq + 1)
	if qq in q:
		print 'pwn! %s' % q

pp = 139992453014430453998401215949514251234596490808993505720945599077885018056158603720666746717084655347876118811778492829985928358117530476386083439571595324274282373537246736307145889839973277883957148017704762606224471507810033841684932650182833495359332798591639430888023393669529795740011504762424059947050L

for kp in range(1,e):
	p = (e * dp - 1)/kp + 1
	if pp % p == 0:
		print 'pwn! %s' % p
```
