首先拿到程序看到几万行的运行记录，第一感觉是把所有跳转语句去掉，然后编译一下从头到尾跑一遍，
不过由于是 MIPS，要弄模拟器啥的，还得把全局变量地址啥的调好，于是懒癌发作，就直接静态看了。

首先 `egrep 'jal|jr' trace_8339a701aae26588966ad9efa0815a0a.log` 看看调用流程，
可以发现基本都是 0x400858 这个函数在递归调用，应该就是关键逻辑了，然后 0x400770 和 0x4007d0 上还有两个小函数。

然后处理下 log，把整个程序按照地址的顺序排好方便看逻辑。
逆完后发现，0x400770 是 strlen，0x4007d0 是 strcpy，0x400858 是个类似快排的排序，
整个逻辑就是对 `string.lowercase + string.uppercase + string.digits + '{}' + flag` 这个串进行了排序。

于是，我们可以先将 flag 用未知量表示，按照 log 的顺序，执行一遍各个操作，模拟排个序，得到：

```
['x0', '0', 'x19', 'x11', '1', 'x7', '2', '3', 'x8', '4', 'x23', 'x18', '5', 'x17', 'x9', 'x13', '6', 'x16', '7', '8', 'x21', '9', 'x15', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'x1', 'c', 'd', 'e', 'x3', 'f', 'g', 'h', 'i', 'j', 'x12', 'k', 'x22', 'x14', 'l', 'm', 'x10', 'n', 'o', 'p', 'q', 'x24', 'x6', 'r', 'x20', 's', 'x2', 'x5', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'x4', '{', '}', 'x25']
```

然后排序过程中，每一次交换其实是确定了一个小于关系，记录下来，然后配合排序结果一起，可以确定绝大多数未知量。
实测是最后有两位没有完全确定下来，于是把四种可能都试着交一下就好……
