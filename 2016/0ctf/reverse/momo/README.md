## momo

大概看了下程序逻辑，有两处puts，根据dword_83FE9C8的值来决定是否输出。动态调试一下并跟踪输入数据，容易看到里面大概实现了一个虚拟机，每次将两个参数放到dword_81FE860 dword_81FE864处进行操作，并把结果放到dword_81FE868中。关注了一下这里进行的操作，可以看到 off_80697A0代表加法， word_81698C0代表减法， off_81AA2F0则是根据两个参数从一个256*256的表中取出结果。

多试了几次发现除了我们的输入外其它参数都是常数的样子，所以就动态跟着全部记下来就好啦。下面是输入`123456789abcd`时的记录过程，后面似乎有点改过不过大概样子还在。

```
804a8c0 +0x9)[0x39] 0x91aa2f0 ->0x3?
804acde -0x2)[0x61]   ->0x51 +0x3)[0x51] ->0x52
804b31f -0xa)[0x6a]  ->0x43 ...->0x11
804b728 -0x5)[0x61] ->0x4e ... ->0x5f
804bc2e -0x7b)->0xffffffba ... ->0xffffffe5
804bf35 +0xd)[0x7a] -->0xffffffc9 ...->0x2c
804c41e +0x1)-0x31--> 0x7 ... ->0x2b
804c90d -0x1)[0x55] ->0x62 ...->0x49
804ce1b +0x2)-0x61 ->0xffffffda ...->0xffffff93
804d2f4 +0x1)[0x4a] ->0x28 ...->0xffffffbb
804d7fb +0x4)-0x39 ->0x2d ...->0xffffff96
804de2e +0x6-0x65 ->0x4 ...->0xffffff92
0x0-0x1-0x73 ->0xffffff8c ...->0x62
0x0+0x14-0x69->0xffffffab  ...->0xffffffc9
0x0+0x7-0x79->0xffffff8e ...->0x47
0x0+0x1-0x32->0xffffffcf ...->0xffffff88
0x0+0xc-0x5a->0xffffffb2 ...->0x3a
0x0-0x9-0x30->0xffffffc7 ...->fffffffd
0x0+0x4-0x63->0xffffffa1...->0x5c
+0xe-0x71 0xffffff9d...->0xffffffc1
0x0+0x14-0x44->0xffd0...->0x11
0x0-0x3-0x4d->0xffb0...->0xffa1
0x0+0x11)[0x42]->0x53...->0xfff2
0x0-0x4)[0x41]->0xffbd...->0x4f
0x0+0x6)[0x7a]->0x7c...->0x33
0x0-0x3-0x30->0xffcd...->0xfffe 
0x0+0x12-0x33->0xffdf...->0x21 0xffffff83
0x0-0x7d...->0xffa2
```

由于每一个输入的计算结果都会与之前的累积结果一起进行查表操作，得到新的累积结果，最后在某处检查了累积结果是否为0，另外还有一处检查没有细看，因为发现令上面每个局部计算结果等于0就会出来flag了，代码如下

```
>>> res=[0x7d,0x33-0x12,0x30+0x3,0x7a-0x6,0x41+0x4,0x42-0x11,0x4d+0x3,0x44-0x14,0x71-0xe,0x63-0x4,0x39,0x5a-0xc,0x32-0x1,0x79-0x7,0x69-0x14,0x74,0x65-0x6,0x39-0x4,0x4a-0x1,0x61-0x2,0x55+0x1,0x31-0x1,0x7a-0xd,0x7b,0x61+0x5,0x6a+0xa,0x61+0x2,0x39-0x9]
>>> res=res[::-1]
>>> s=''
>>> for ch in res:
	s+=chr(ch)
>>> s
'0ctf{m0V_I5_tUr1N9_c0P1Et3!}'
```
