这题咋一看貌似没问题，但是考虑到这题给的是 ssh，要求本地提权的，而不是 nc 远程，那么就有了个很明显的条件竞争。

程序首先 stat 判断了文件大小，然后直接读入了整个文件，没有任何长度限制，
那么我们只要在这两步操作直接改掉了这个文件，那么就有了个栈溢出。
为了方便我们调试，我们可以首先 patch 掉程序的大小判断，确认我们的 payload 能够拿到 shell 再做竞争。

然后这个栈溢出的利用也是有点疼，程序是静态编译的，并且溢出用的 copy 限制了不能使用 `\x00`，不过好在各种各样的 gadget 比较多，于是可以玩的花样也就多了。

要调 execve 的话，需要 `int 0x80`，几个寄存器参数如下：

```
eax -> 0xb
ebx -> (char *) path of elf
ecx -> (char **) args
edx -> (char **) env
```

首先 eax 的设置是通过 `xor eax, eax; add eax, 0xb` 来实现，
ecx、edx 本来是设置成 NULL 就好的，但是由于要避免 `\x00` 字符，这里我是设置成了指向一个全 0 的区域指针。
比较麻烦的是 ebx 的设置，我们需要在内存中构造出一个 `/bin/sh` 的字符串，这里我采取的方式比较猥琐，
首先建了个 `/tmp/bin/sh` 的文件夹，将脚本放在该文件夹下运行，
然后通过 `getcwd` 获取当前工作目录，从而在内存中得到了 `/bin/sh` 字符串。

溢出搞定后，剩下竞争的事就好办了，反正不要求一次成功，多跑下就好，
不过比较坑的是，自己虚拟机测试的时候，基本上 10 次以内妥妥搞定，
然而服务器上跑的时候，成功率非一般的低，调了半天延时后死循环跑了好久才搞定。

PS：搞定后没一会再看的时候服务器挂了的样子，难道是我死循环的锅……
