PC、Android 程序逻辑应该差不多，这里以 Android 为例。

## 学生组

程序首先载入 `/data/local/tmp/libZapus.so`，调用其中的 `zapus_get` 函数初始化了一段内存，
然后调用 `sub_F44` 对这段内存做了个变换，变换之后的结果要求为一个特定值（由于 PIE 的存在，这个值每次运行的时候并不一样）。

`sub_F44` 做的事情也很简单，其将输入输出都看做 bit 流，从 0x40AC 处获取了 0x800 大小的常量数组，即 0x4000 的 bit 流。
然后对于此常量，将其 128 个一组与输入进行 `&` 操作，统计这一组中的 1 的个数（xor）作为输出的一个 bit。
对应的 Python 代码如下：

```python
def and_all(x, y)
    s = ''
    for i in xrange(len(x)):
        s += chr(ord(x[i]) & ord(y[i]))
    return s

def transform(s):
    return unbits([bits(and_all(x, key)).count(1) & 1 for x in group(16, s)])
```

于是，在我们知道确定输出的情况下求输入的话，针对每一个输出 bit，可以得到一个方程，即总共 128 个 128 元一次异或方程组，求解即可。
由于系数是又常量数组决定的，与输入无关，故可以提前对参数矩阵求逆，不过是在模 2 的域下求逆了。

```c
for (int i = 0; i < 0x10; ++i) {
    for (int j = 0; j < 8; ++j) {
        a[i * 8 + j][MAX_N] = (aim[i] >> (7 - j)) & 1;
    }
}
for (int i = 0; i < 0x80; ++i) {
    for (int j = 0; j < 0x10; ++j) {
        for (int k = 0; k < 8; ++k) {
            a[i][j * 8 + k] = (ida_chars[i * 0x10 + j] >> (7 - k)) & 1;
        }
    }
}
```

接下来，`sub_1060` 看起来是对 so 本身进行了什么校验，猜测估计 crc32 之类的，随便点进去看了几个常数，果然 crc32，还真是一点惊喜都没有。

程序要求 crc32 为特定值，照着 crc32 碰撞的办法补几个字节纠正下 so 的校验值就好了。
不过这里的值为一个指针，同样受 PIE 影响，每次运行都不一样，所以要在 so 中进行自修改。
自己伪造 crc32 的代码找不到了，于是去网上下了个 C 版代码，结果没想到在 x86 上编译都正常，cross compile 运行结果就是不对，调了半天总算搞定。

## 社会组

整个程序第一眼跟学生组差不多，`sub_F90` 做一个变换，里面比较无聊的先把常量变换了下，懒得管了，直接动态 dump 下来好了。
`sub_F90` 后半部分那个循环和学生组的乍一看一样，仔细对比下会发现比较无聊的把常量数组 byte 中 bit 的高低位换了下，于是改下就好。

过了 `sub_F90` 之后，程序除了校验了 crc32，还自定义了一个校验值（gg，竟然不是自定义的，FNV-1a，长见识了）：

```python
x = 0x811C9DC5
for c in s:
    x = ((x ^ c) * 0x1000193) & 0xffffffff
```

同时要求两个等于一个固定值，一时之间还真没啥太好的计算办法。
直接暴力的话，按照固定值随 PIE 变化的情况来看的话，这 so 一个函数运行个几个小时不知道能不能算通过，貌似题目要求并不限制执行时间。

干这么暴力的事情了似乎不太好，于是看看降低了难度的新版题目，果然发现目标值真的固定了，不受 PIE 影响了，0x614C5347。
于是偷懒先写了个 Python 暴力，试了试感觉这得跑个半天的样子。算了，还是重写了个 C 跑，服务器分分钟跑出来。

暴力策略：原始 so 随机加四个字节使 crc32 随机，然后调整 crc32 正确（会再加 4 个字节），然后对加上这 8 个字节的结果校验 FNV-1a，
其中 crc32 和 FNV-1a 都可以用之前计算的中间结果开始计算，即每次只要为加的 8 个字节计算就好，加快暴力速度。

PS: [libZapus.so](./shehuizu/libZapus.so) 是已经调整好校验值的，多余的调试 log 就懒得删了。
