函数`process`实质上是个GF(2**256)上的平方运算，用于产生key与明文xor，由于后两次产生的key我们都能拿到，所以实质上是求这个域下的开方操作。

sage有支持但当时并没去试，只是看了下发现二进制平方后`1->01 0->00`，记最右为第0位，可见正常情况下不取模奇数位必定为0，而且P的奇数位只有第5位不为0，所以稍稍试一下0-4位是否需要加上P，后面每个`2n+1`位不为0就在`2n-4`位加上P，可以还原出不取模的结果，然后把奇数位丢掉就行了。

草稿如下

```
>>> P = 0x10000000000000000000000000000000000000000000000000000000000000425L
>>> fake_secret2 = "feeddeadbeefcafefeeddeadbeefcafe"
>>> fake_secret1 = "I_am_not_a_secret_so_you_know_me"
>>> def str2num(s):
    return int(s.encode('hex'), 16)

>>> c3=0xe913db07cbe4f433c7cdeaac549757d23651ebdccf69d7fbdfd5dc2829334d1b
>>> c2=0x630eb4dce274d29a16f86940f2f35253477665949170ed9e8c9e828794b5543c
>>> c1=0xaf3fcc28377e7e983355096fd4f635856df82bbab61d2c50892d9ee5d913a07f
>>> c2
44804956138029594877678183404451458957271575260252646638476893887508109415484L
>>> def process(m, k):
    tmp = m ^ k
    res = 0
    for i in bin(tmp)[2:]:
        res = res << 1;
        if (int(i)):
            res = res ^ tmp
        if (res >> 256):
            res = res ^ P
    return res

>>> key3=c3^str2num(fake_secret2)
>>> key2=c2^str2num(fake_secret1)
>>> key3
64890539320374511691218631652379979845114477376165652980989564040672386886526L
>>> def decode(x):
	x1=x
	t=bin(x1)[2:]
	check=t[-2::-2]
	res=t[::-2][::-1]
	return int(res,2)

>>> key2=19141729116541688030150932740522363381296784947904431401814904894121986111833L
>>> t=key2
>>> bin(t)
'0b10101001010001110101011011000110111101000110101011110111101110010010011001100100110110001100111001011110010000001000000011011000110011001010010001011011111011110011100000100110000010111010111101001111110101111011001110100011100011111010100011100101011001'
>>> bin(t^(P<<0))
'0b10010101001010001110101011011000110111101000110101011110111101110010010011001100100110110001100111001011110010000001000000011011000110011001010010001011011111011110011100000100110000010111010111101001111110101111011001110100011100011111010100011110101111100'
>>> bin(t^(P<<1))
'0b100010101001010001110101011011000110111101000110101011110111101110010010011001100100110110001100111001011110010000001000000011011000110011001010010001011011111011110011100000100110000010111010111101001111110101111011001110100011100011111010100011000100010011'
>>> bin(t^(P<<2))
'0b1000010101001010001110101011011000110111101000110101011110111101110010010011001100100110110001100111001011110010000001000000011011000110011001010010001011011111011110011100000100110000010111010111101001111110101111011001110100011100011111010100010100111001101'
>>> bin(t^(P<<3))
'0b10000010101001010001110101011011000110111101000110101011110111101110010010011001100100110110001100111001011110010000001000000011011000110011001010010001011011111011110011100000100110000010111010111101001111110101111011001110100011100011111010100001100001110001'
>>> tt=t^(P<<3)
>>> while True:
	st=bin(tt)[2:]
	j=len(st)-6
	while (j>=0) and st[j]=='0':
		j-=2
	if j<0:
		break
	pos=len(st)-j-6
	tt^=(P<<pos)

	
>>> tt
3420696397594762629652223244465859241431571503099724131242808161448643575005680008163239129277347278016668042258906431994461836969451960302766761976071444L
>>> 

>>> tmp3=decode(1064073570121161635722790143386875309401511637204153392601764084122925467692826969465432457544354454281893685346572074779235024842012319007089376129978433L)
>>> process(tmp3,0)==key3
True
>>> seed=tmp3^key2
>>> key2
19141729116541688030150932740522363381296784947904431401814904894121986111833L
>>> tmp2=decode(3420696397594762629652223244465859241431571503099724131242808161448643575005680008163239129277347278016668042258906431994461836969451960302766761976071444L)
>>> process(tmp2,0)==key2
True
>>> key1=tmp2^seed
>>> ans=key1^c1
>>> c1
79267468907649481004031669197619294997861358148687669164280161107568250560639L
>>> hex(c1)
'0xaf3fcc28377e7e983355096fd4f635856df82bbab61d2c50892d9ee5d913a07fL'
>>> hex(ans)
'0x74305f42335f72346e646f4d5f656e305567685f31735f6e6563337335617259L'
>>> '74305f42335f72346e646f4d5f656e305567685f31735f6e6563337335617259'.decode('hex')
't0_B3_r4ndoM_en0Ugh_1s_nec3s5arY'
>>> 
```
