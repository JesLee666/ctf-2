## 解题思路

在 standard 的基础上，advance 只是在 standard 的 code 转换完后多调用了一个 0x6158，大致参数是 standard 转换完的 code 和常量字符串 `welcomegslab2018`。
首先会发现转换后的 code 长度应该是 16 的倍数，然后 16 个一组进行操作。
稍微调试一下，可以看出，常量字符串会扩展生成一张表，输入首先转换成 `4 * 4` 的矩阵，然后 xor 了表中数据，接下来进行了一个按行的 shift 操作，接下来就是一个 10 次的循环。
等等，看到这些操作，本能映入脑海的无疑就是 AES，带着这一猜想过一眼程序结构，可以很明显发现常量串正好 16 位，
最开始 expand key，然后 add round key，shift row，
接着循环 10 次，sub bytes，一堆奇怪 switch，add round key。
简直就是标准的不能在标准的 AES 加密流程了，那堆 switch 仔细看一眼常量或者干脆读一下每个 case，会发现用到的 9 11 13 14，正好就是 mix columns 时用到的多项式。
仔细检查一下各个常量表，sbox 256 个 byte 无重复，没问题，expand key 结果 176 个 byte，没问题，
不过 expand key 用的 sbox 貌似不是后面的 sbox，不过无所谓了，直接用 expand 后的结果就好了。
然后找个标准 AES 实现，换掉 sbox 和轮密钥，会发现结果不对。
仔细调试一下会发现，轮密钥的使用很奇怪，流程是加密的流程，但轮密钥是倒序使用（解密的方式），mix column 也是解密的参数，其次轮密钥的每四个 byte 中有两个反过来了。
改了半天 AES 各种对不上，感觉出题人把所有能换的表都给魔改了（给出题人深深地跪了），于是干脆从头跟着程序流程裸写一份好了，反正不复杂。
正向测试通过后，对着反着写一份，稍微麻烦点的就是 mix columns 需要将 14, 11, 13, 9 对应换成多项式的逆 3, 1, 1, 2。
最后在 standard 代码中算 code 时额外调用一下“解密”操作即可。

## standard 思路（附）

老规矩，下下来题目，解包，首先看说明，文件名乱码也就认了，万万没想到，文档有一个直接打不开，还好另一个打的开的看起来写的是规则，那先按规则做题好了。

不知道主办方是不是看我去年用 z3 angr 不太爽，或者看我复用 so 不太爽？上来规则里面就是不让有三方依赖，不让任何形式截取逆向汇编（IDA F5 结果可以复制么？？？）。
好吧，我们听主办方的，规规矩矩逆向，不偷懒跑符号执行了，一点代码也别复用了。
只是还真有点不清楚 Python 的库中哪些是自带的，哪些是 pip install 的了。。。。

1. 按照流程来，首先 0x4864 对 key 做了检查，大致可以看出是要求是 39 位，其中 32 位是 hex digit，7 位是 `#`，并将 key 全部 `toupper` 后按照 `#` 将输入分段，大致可以感觉出是 4 个一组，一共 8 组。

1. 接下来 0x496C 对这个 8 * 4 的输入，进行了惨无人道的简直毫无规律的各种小操作（`+`, `-`, `*`, `/`, `%`, `^`, `&`, `|`）将输入转换成 5 个 qword，尤其配上这 cpp 的结构与冗余，整个代码不忍直视。
   最好的方法无疑是符号执行或者直接复用代码，因为这个操作很显然在题目的目标下（根据 key 算 code），不需要进行逆运算。
   但是为了满足出题人变态的要求，只能硬着头皮一点点看下来了，但不知道会不会有小的错误，毕竟没有办法进行完全的测试。

1. 对于 standard 难度，0x7114 对输入 code 做了个变换，很明显可以看出是个换了表的 base64 decode（为什么都这么喜欢 base64，能不能来点新意？）。大概扫下后面的逻辑可知，这里最后得到的结果应该是 4 个 qword。

1. 0x5232 要求了上面一步最后一个 qword 是常量 0x32303138，接下来 0x5658 对剩余的 8(5 + 3) 个 qword 进行了校验。
   校验很明显是 3 个等式，显然这里用 solver 可以轻松愉快的解决，不过 solver 的库一般含有 binary，难以满足题目的使用要求，故而只好手解方程。
   大致可以转换为 `x ^ 2 == 0` 这种形式，于是按说可得唯一解。
   解方程过程中会有个除法，但对于本题，该除法可以整除，所以可以简单算得，不过暂不确定在模 2^64 的域下能否保证没有多解，数学都还给老师了，懒得算了，有一组解就好。

最后随机生成 key 测试了一会，没有发现 failed 的情况，就假装第二步细节没有逆错吧。。。

## keygen 运行环境

Python 2.7.14

依赖 pwntools，鉴于源代码实在太多，人工抽取了用到的函数附在 `util.py`
