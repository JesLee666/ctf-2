这题很明显在strcpy的时候会有溢出，可以直接覆盖到返回地址，但是，由于溢出之后还有很多代码，我们需要保证程序在函数返回之前不能崩溃或者exit，于是乎我们观察下局部变量的位置：

```
ofd    esp+0x6c
ifd    esp+0x68
ofile  esp+0x58
ifile  esp+0x38
buf    esp+0x18
```

可以发现，strcpy的溢出导致我们可以覆盖`ofile`、`ifd`、`ofd`，也就是说，我们可以同时控制输入和输出文件，但是要保证两个文件都能以相应的权限打开，否则程序会直接exit，导致我们即使覆盖了main函数返回地址也没用。

因此，如果想要能够正常的覆盖，我们必须精心设计文件名并建立好相应的文件。

然后，我们仔细想想会发现，我们其实完全没有必要拿到shell，我们只要能让程序从存password的文件读入，写到一个我们当前用户能读的文件即可，这样无疑可以简化我们的payload。

由于strcpy会被`\x00`截断，也就是说，我们的输入中是不能含有`\x00`的，那么我们的ofile一定是ifile的后缀，于是乎，我们其实最好的选择就是，ofile用相对路径，ifile用绝对路径，这样很轻松就能使得两个路径都合法，因此我们得到类似下面的payload：

```
////////////////etc/narnia_pass/narnia4
```

使得ofile正好为narnia4即可。

然后需要注意的是，我们要给我们当前的整个工作目录加上权限，而不是只给工作目录下的narnia4文件加上权限，否则narnia4用户是无法查看这个属于narnia3用户的目录的文件的，我就在这点上被坑了好久。